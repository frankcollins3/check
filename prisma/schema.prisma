 generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model users {
  id                      Int         @id @default(autoincrement())
  location_id             Int?        
  username                String      @unique        
  email                   String      @unique
  password                String 
  birthday                String               //age                     Int     
  joinday                 String
  last_username_change    DateTime?      
  full_name               String?
  //                      profile_picture         String?
  icon                    String
  cover_photo             String?
  ballot_title            String? 
  gender                  String?
  orientation             String?
  ethnicity               String?
  role                    String?
  //                      preferred_language      String,               // nullable (english if so) 

  no_ads                  Boolean?     
  //                      no_app_anims      Boolean?  // for now removing there doesn't look to be much animation besides intro text swap.
  post_order              String?     //    time (newest first or oldest first) | likes   omg what about [32,29,1,287] // user drag and drops indexes of their current posts (represented by post images as well) user can put any posts in any order. regarding latency which the feature sounds to bring much of, maybe it's not so bad because it shows on profile. I thought of every time the user scrolls which sounds insanely latent.
  show_followers          Boolean?    // might change to string for      'yes' | 'no' | followers | followed_users | f_f

  avg_likes               Int?
  avg_comments            Int?
  daily_scrolling         Int?
  avg_scrolling           Int?
  avg_shares              Int?
  total_posts             Int?
  total_followers         Int?
  total_following         Int?
  //                      who_can_trash_post      String?     //  'yes' (everyone) 'no' (no one) 'followers', 'followed users', 'f_f' (friends,followers)
  i_can_trash_u           Boolean?    // when user clicks the trash can there will be an expression that evaluates them for spam, low engagement, blabla to fight troll accounts bullying others by artifically overtrashing posts by having separate accounts. also considered allowing users to have a "can_trash_list" 

  //                      is_verified             Boolean?    // "verified" account
  //                      is_authorized           Boolean?    // 2FA 
  //                      icon_border_img         String?
  
  malicious_action_tally  Int?
  trash_u_today           Int?       
  trash_me_today          Int?
  trash_u_30              Int?      
  trash_me_30             Int?
  total_sessions          Int?
  sessions_this_year      Int?

  vibe_u_today            Int?
  last_vibe_gift          DateTime?
  spam_percent            Int?

  reported_posts_me       Int? 
  sus_start_date          DateTime?
  has_reported_u          Int?  

  explicit_posts          Int?
  has_marked_exp          Int? 
  thought_limit           Int? 
  comment_limit           Int?  
  timestamp               DateTime    @default(now())
  updatedAtBin            String[] // issue #108 performance bank: ez to stop user from purposely hitting DB too much, keep updating over & over

  days                    days[] @relation("userDays")  
  thoughts                thoughts[] @relation("userThoughts")
  fields                  fields[] @relation("userFields") 
  media                   media[] @relation("userMedia") 
  listeners               listeners[] @relation("userListeners")
  shares                  shares[] @relation("userShares")
  likes                   likes[]  @relation("userLikes")
  stars                   stars[]  @relation("userStars")
  followers               followers[] @relation("userFollowers")       
  following               followers[] @relation("userFollowing")
  blocks                  blocks[] @relation("userBlocks") 
  blocked                 blocks[] @relation("blockedUsers") 
  reactions               reactions[] @relation("userReactions")
  suggestions             suggestions[] @relation("userSuggestions") 
  ballots                 ballots[] @relation("ballotStartedByUser") 

  from_me_pay             payments[] @relation("fromUserPayments")
  for_me_pay              payments[] @relation("forUserPayments")
  from_me_prank           pranks[] @relation("userPranks")
  for_me_prank            pranks[] @relation("userPranked")
  algo_settings           algosettings[] @relation("userAlgosettings")

  privacy                 privacy? @relation("userPrivacy")       
  greatfullagain          greatfullagain? @relation("userGreatfullagain")     
  
  for_notifications       notifications[] @relation("userForNotifications")
  from_notifications      notifications[] @relation("userFromNotifications")
  forMessages             messages[] @relation("userForMessages") 
  fromMessages            messages[] @relation("userFromMessages") 

  location                locations? @relation("locationUsers", fields: [location_id], references: [id])
}

model days {            
  id                      Int      @id @default(autoincrement())
  user_id                 Int?     
  username                String?
  user_profile_icon       String?
  //                      user_is_verified        Boolean?
  location_id             Int?
  category_id             Int?
  
  title                   String?  
  caption                 String?
  
  non_anonymous           String      // instead of private_post: boolean     'private' would be set here just for a user's internal journal 
  thoughts_ok             String             
  shareable               String     
  downloadable            String  
  voice_comments_ok       Boolean
  video_comments_ok       Boolean       // maybe weekends only ?  
  
  //                      ai_photos_ok            Boolean?              // if user doesn't have photos AI can make photos from day-data/description
  show_views_ok           Boolean?       // 3000 views // might be string for f_f, followers, followed_users, 
  show_time_ok            Boolean?       // 2d             long ago
  public_likes            Boolean?
  thought_blanks_ok       Boolean?      // weekend -> no thoughts ? user can write to the thoughts but the UI will say username. 3 hours.
  thought_blank_time      String?       // explained above. thoughtBlank 
  thought_blank_user      String?       // username
  rlly_like_ok            String?       // initial messaging. Based on comments, during "rlly/superlikes[tinder]" only superliker & poster can see
  rlly_like_group         Boolean?      // true ? group (all superliked users have separate convo in comments): solo comments
  commenter_can_determine Boolean?      // checkbox -> relates to {table.stars} stars_show_avg, stars_show_users -> a commenter can determine, during comment submission, that other commenters can see 1-5 rating average, or even list of all people and their submitted data.
  

  // WONT NEEED THIS!                      is_draft                Boolean?      
  is_reported             Boolean?    
  feedface                String              // 'thoughts' | 'greatfullagain' | 'moments' could also be 'img-url' 
  is_in_trash             Boolean?
  trash_tally             Int?
  date                    String            // non nullable because graphQL resolver: getMostRecentUserDayPost would depend on this or timestamp.
  //                      posted_date             String            // date could be from 5 years ago but posted today.
  lock                    String?            // was lock_restriciton
  unlock                  String?            // was lock_activity
  //                      i_can_unlock         Boolean? // if custom lock? like "spit bars" <MainRootComments/> lock icon allows posting user to unlock them. catch all solution against writing a new function and useEffect for every new feature that gets added but maybe some features get internal code updating. 
  sus_content             Boolean?
  //                      reaction_logo           String[]    // 2 little icons next to each other.  or just a single string
  timestamp               DateTime  @default(now()) 
  updatedAtBin            String[]

  thoughts                thoughts[] @relation("dayThoughts") 
  fields                  fields? @relation("dayFields")
  moments                 moments? @relation("dayMoments")
  media                   media[] @relation("dayMedia")
  notifications           notifications[] @relation("dayNotifications")
  ballots                 ballots[] @relation("dayBallot")
  shares                  shares[] @relation("dayShares")
  payments                payments[] @relation("dayPayments")
  listeners               listeners[] @relation("dayListeners")
  like                    likes[] @relation("dayLikes")
  reactions               reactions[] @relation("dayReactions")
  pranks                  pranks[] @relation("dayPranks")

  greatfullagain          greatfullagain? @relation("dayGreatfullagain")

  user                    users?  @relation("userDays", fields: [user_id], references: [id])  
  location                locations? @relation("locationDays", fields: [location_id], references: [id])
  category                categories?  @relation("categoryDays", fields: [category_id], references: [id])
}

model thoughts {          
  id                      Int      @id @default(autoincrement())
  user_id                 Int?      // not optional but handled logic side: circular dependency if it's optional during user create.
  username                String?   // denormalizing for the comments feature to avoid requerying database.
  user_profile_icon       String?   // denormalizing like username above.
  //                      user_is_verified        Boolean?          //  * * * PROBABLY DOING!

  day_id                  Int?
  location_id             Int?      // location for standalone thoughts if the posting-user so describes.
  moment_id               Int?
  greatfullagain_id       Int?
  parent_thought_id       Int?     
  
  sus_content             Boolean?      // sus being: still-under-suspense
  suggestion_id           Int?
  feedgame_id             Int?
  meme_id                 Int?
  title                   String?
  thought                 String?   // for comments only. 
  thoughts                String[] @default([]) // even a single standalone thought that belongs to post goes into array.

  non_anonymous           String  // might make these 4 optional cuz of child_thoughts/thoughts-as-comments.. can also just autofill those data to be no with {thoughts_ok: true}
  downloadable            String
  starrable               String    
  thoughts_ok             String
  comment_icon            String?       // for comments. 1 big comment box instead of separated. icon shows which part of post comment belongs
  is_voice                Boolean?       // shoutout to naval & airchat & yallalive. no one's the first. no one's the last. 
  is_video                Boolean?      

  stars_show_avg          Boolean?     // TOGGLED OFF with days.commenter_can_determine * *  {question} mark appears, user clicks, and the 1-5 stars fills the rating, color-coded.
  stars_show_users        Boolean?     // if this is true and user clicks ^ ^ (?) -> then replace actual comment with list of ratings until toggle back

  blank_thoughts_ok       Boolean?        // weekend posted posts, if no thoughts, commenting users, if posting-user opted in, can post
  blank_thoughts_username String?
  //                      blank_thougths_date     String?

  is_reported             Boolean?    
  is_in_trash             Boolean?
  //                      is_comment              Boolean?
  //                      is_pinned               Boolean?
  trash_tally             Int?      
  date                    String?
  on_profile              String?            
  timestamp               DateTime @default(now())
  updatedAtBin            String[]

  user                    users?  @relation("userThoughts", fields: [user_id], references: [id])   
  days                    days? @relation("dayThoughts", fields: [day_id], references: [id])      
  moment                  moments? @relation("momentThoughts", fields: [moment_id], references: [id])
  greatfullagain          greatfullagain? @relation("greatfullagainThoughts", fields: [greatfullagain_id], references: [id])
  location                locations? @relation("locationThoughts", fields: [location_id], references: [id])
  suggestion              suggestions? @relation("suggestionThoughts", fields: [suggestion_id], references: [id])
  feedgame                feedgames? @relation("feedgameThoughts", fields: [feedgame_id], references: [id])
  
  parent_thought          thoughts? @relation("parentThoughts", fields: [parent_thought_id], references: [id])
  child_thoughts          thoughts[] @relation("parentThoughts")

  media                   media[] @relation("thoughtMedia")
  stars                   stars[]  @relation("thoughtStars")
  share                   shares[] @relation("thoughtShares")
  notifications           notifications[] @relation("thoughtNotifications")
}

model moments {       
  id                      Int      @id @default(autoincrement())
  day_id                  Int?     @unique
  moment                  String?    // possibly getting rid of these and making the program expect an iterable []
  moments                 String[]   @default([])
  //                      title                   String[]   @default([]) //    {moments} are the titles of the moments the moments themselves are pictures. {moments} & {captions}        i.e.    "Yay or Nay" --- keto pizza. each index corresponds to the moments[] array.
  caption                 String[]   @default([]) 
  on_profile              String?
  timestamp               DateTime @default(now())
  updatedAtBin            String[]
  
  day                     days? @relation("dayMoments", fields: [day_id], references: [id])
  thought                 thoughts[] @relation("momentThoughts") 
  notification            notifications[] @relation("momentNotifications")

  media                   media[] @relation("momentMedia")
} 

model fields {
  id                     Int      @id @default(autoincrement())
  user_id                Int?           // primarily day_id only this is for the profile fields that live outside of posts/day-data
  day_id                 Int?   @unique // might remove @unique because of "walk in their shoes/wits fields" multiple options could
  wits_ok                Boolean?       //  yes or no:      whether fields/activities/areas-of-life can be copied. specified with this column.
  wits_username          String?    // denormalized username of the posting-username of the walk in their shoes/wits fields as a shoutout for coming up with those fields. no association since wits_fields is M:M
  decidedo_id            Int? 
  fields                 String[] @default([])
  checkbox               Boolean[] @default([])    // true | false the actual checkbox themselves whether they are checked or not. 
  constantsee            String[] @default([])    // 2/25/24 basically category-related-reminders to maintain object constancy of perspective that a user can attach phrases to certain activities that might influence them to think about it in a different way. 
  users_checkboxes       Boolean[] @default([])   // lol so user can write [true, true, false] in case they want checkboxes for certain activities and not others
  text                   String[] @default([])
  //                     decide                 String?        // possible scopecreep. {decide,do} with table only. decidedo adjacent to, not actually of fields. but still shares same part of post.
  //                     do                     String?            
  dream                  String?            //  user might have to listen to the post to get access to any dreams. possibly.
  likeable               String
  //                     thoughts_ok       String   //   wonder what to do with comments.. no association. consider habits & values
  on_profile             String?
  timestamp              DateTime @default(now())       
  updatedAtBin           String[]
   
  user                   users? @relation("userFields", fields: [user_id], references: [id])
  day                    days? @relation("dayFields", fields: [day_id], references: [id])
  decidedo               decidedo? @relation("decideDoFields", fields: [decidedo_id], references: [id])     

  myhabits               myhabits[] @relation("fieldMyHabits")
  myvalues               myvalues[] @relation("fieldMyValues")
  likes                  likes[] @relation("fieldLikes")
  share                  shares[] @relation("fieldShares")
  algo_settings          algosettings[] @relation("fieldAlgosettings")
  media                  media[] @relation("fieldMedia")
}

model witsfields {
  id                     Int      @id @default(autoincrement())
  copy_fields_id         Int?                // copy only the activities like "mixing" / "jokes" / "climbing" / "coding" no text or elaboration           
  copy_user_id           Int?                // id of the user whose post is being copied / pretty much shared onto a new post.
  credit_username        String?             //
  paste_fields_id        Int?                // pasted fields is the new fields id basically the destination of original data.
  paste_user_id          Int?     // id of the user who is sharing the copy_fields_id onto their own post as their own fields (crediting other user)

  swap_fields_id_1       Int?         // in case user is full on trading fields/activities/areas-of-life 
  swap_fields_id_2       Int?         // swapping users. these users both 
  swap_username_1        String?  
  swap_username_2        String?

  timestamp              DateTime @default(now())
  updatedAtBin           String[]

//    M:M table WITS: walk in their shoes. apply someone else's fields as ur own! (credited of course) or trade fields!
//    WITS TABLE now essentially purposed so users can look up posts that other users are copying.
//    could think of other fields like (go_ok?) (notes/feedback) but might leave that alone.
}

model greatfullagain {     
  id                     Int      @id @default(autoincrement())
  user_id                Int?     @unique
  day_id                 Int?     @unique 
  concern                String?
  question               String?
  criticism              String?
  words                  String[] @default([])
  greatfull              String[] @default([])
  zoom_in_msg            String?  // github issue #144. over questions like: "how can I see what I cant see" - johnson -> 
  zoom_out_msg           String?  // github #144 ------------- MIGHT ALLOW USER TO CHANGE: zoom_in, zoom_out -----------
  zoom_in                String?  // this is the response to zoom_in_msg 
  zoom_out               String?  // zoom_out_msg is the question this is the answer. 
  on_profile             String?
  show_cgc               String?   // considered non-optional. if it's empty then yes: show posting-user's concern,question, or criticism
  timestamp              DateTime @default(now())  
  updatedAtBin           String[]

  user                   users? @relation("userGreatfullagain", fields: [user_id], references: [id])
  day                    days? @relation("dayGreatfullagain", fields: [day_id], references: [id])
  
  thoughts               thoughts[] @relation("greatfullagainThoughts")  
  media                  media[] @relation("greatfullagainMedia")       

  myconcerns             myconcerns? @relation("greatfullagainMyConcern")     
  myquestions            myquestions? @relation("greatfullagainMyQuestion")   
  mycriticisms           mycriticisms? @relation("greatfullagainMyCriticism")                         
}

// among first votes to be held.    I imagine feature to be cool with: locks. that posting user couldn't determine their own questions.
// activity metrics possibly not even posting-user-determined, if posting-user opts in AI / automatic-code: creates lock|activity 
// only that activity would be source of truth and against being able to game that system maybe posting-user couldn't create lock|activity

// ourzoomins           // if we go with zoom_in_msg. COMMUNITY_BANK: questions like i.e. : "how can I see what I cant see" - bryan johnson
// ourzoomouts          // if we go with zoom_out_msg 
// { timeframe: string } what could I do differently this month ? | if I could live this year over would I do anything different.
// maybe people figure out some trendy / super creative or fun way to use the fact that you could customize those columns. 
// also want to make the ../../-meta-point observable:    it would be cool if the app already existed and community voted {zoom_in_msg} {table.ourzoomins}


// ourlocksactivities: community bank: {days.lock}, {days.unlock}. especially voice comment features #177, elaboarated more in #137
// M:M ? {table.users, table.locks} & ourlocksactivities M:M. but {table.locks} denormalized as {days.lock,days.unlock} 
// just b4 making table @ [5-27 11:42AM memorial day]: realized why not just make this JSON file manually update it?

model ourlocksactivities {
  id                  Int      @id @default(autoincrement())

//  user fields unused most cases, but factoring i.e. instance: some user totally 100% deserves credit introducing new lock then they show
  user_id             Int?
  username            String?
  user_profile_icon   String?
  //                  ballot_id           Int?  // if the feature was introduced by vote in the app or by pushing thru mods or app-channels

  lock                String?
  activity            String?


  timestamp           DateTime @default(now())
  updatedAtBin        String[]
}


model ourconcerns {
  id                  Int      @id @default(autoincrement())
  concern             String
  timestamp           DateTime @default(now())  
  updatedAtBin        String[]
       

  myconcerns          myconcerns[] @relation("ourConcernConcerns")
  
  ballots             ballots[] @relation("ourConcernBallots")
}

model myconcerns {
  id                  Int      @id @default(autoincrement())
  user_id             Int         
  greatfullagain_id   Int      @unique
  ourconcern_id       Int?
  concern             String?
  
  timestamp           DateTime @default(now())    
  updatedAtBin        String[]
  
  greatfullagain      greatfullagain @relation("greatfullagainMyConcern", fields: [greatfullagain_id], references: [id]) 
  ourconcerns         ourconcerns? @relation("ourConcernConcerns", fields: [ourconcern_id], references: [id])

  algo_settings       algosettings[] @relation("myConcernAlgosettings")
}

model ourquestions {
  id                  Int      @id @default(autoincrement())
  question            String
  timestamp           DateTime @default(now())       
  updatedAtBin        String[]

  myquestions         myquestions[] @relation("ourQuestionQuestions")
  ballots             ballots[] @relation("ourQuestionBallots")
}

model myquestions {
  id                  Int      @id @default(autoincrement())
  user_id             Int         
  greatfullagain_id   Int      @unique
  ourquestion_id      Int?
  concern             String?
  
  timestamp           DateTime @default(now())    
  updatedAtBin        String[]
  
  greatfullagain      greatfullagain @relation("greatfullagainMyQuestion", fields: [greatfullagain_id], references: [id]) 
  ourquestions        ourquestions? @relation("ourQuestionQuestions", fields: [ourquestion_id], references: [id])

  algo_settings       algosettings[] @relation("myQuestionAlgosettings")
}

model ourcriticisms {
  id                    Int      @id @default(autoincrement())
  criticism             String  
  timestamp             DateTime @default(now())       
  updatedAtBin          String[]

  mycriticisms          mycriticisms[] @relation("ourCriticismCriticisms")
  ballots               ballots[] @relation("ourCriticismBallots")
}

model mycriticisms {
  id                  Int      @id @default(autoincrement())
  user_id             Int         
  greatfullagain_id   Int      @unique
  ourcriticism_id     Int?
  criticism           String?
  
  timestamp           DateTime @default(now())    
  updatedAtBin        String[]
  
  greatfullagain      greatfullagain @relation("greatfullagainMyCriticism", fields: [greatfullagain_id], references: [id]) 
  ourcriticism        ourcriticisms? @relation("ourCriticismCriticisms", fields: [ourcriticism_id], references: [id])

  algo_settings       algosettings[] @relation("myCriticismAlgosettings")
}

model ourhabits {    
    id                  Int      @id @default(autoincrement())  
    habit               String   @unique
    timestamp           DateTime @default(now())          
    updatedAtBin        String[]

    myhabits            myhabits[] @relation("ourHabitHabits")
    ballots             ballots[] @relation("ourHabitBallots")
}

model myhabits {
    id                  Int      @id @default(autoincrement())  
    user_id             Int
    field_id            Int?
    ourhabit_id         Int?
    habit               String? 

    start               String[] @default([])
    stop                String[] @default([])
    active              Boolean? 
    notes               String?
    timestamp           DateTime @default(now())
    updatedAtBin        String[]

    field               fields? @relation("fieldMyHabits", fields: [field_id], references: [id])
    ourhabits           ourhabits? @relation("ourHabitHabits", fields: [ourhabit_id], references: [id])  
}

model ourvalues {    
    id                  Int      @id @default(autoincrement())  
    value               String   @unique
    timestamp           DateTime @default(now())          
    updatedAtBin        String[]
    
    myvalues            myvalues[] @relation("ourValueValues")
    ballots             ballots[] @relation("ourValueBallots")
}

model myvalues {
    id                  Int      @id @default(autoincrement())  
    user_id             Int
    field_id            Int?
    ourvalue_id         Int?
    value               String?    
    notes               String?
    timestamp           DateTime @default(now())
    updatedAtBin        String[]

    field               fields? @relation("fieldMyValues", fields: [field_id], references: [id])
    ourvalues           ourvalues? @relation("ourValueValues", fields: [ourvalue_id], references: [id])    
}

// model media { // mediatype: 'string', media_tag } // 'images' | 'videos' | 'mp3|wav'   ... can belong to fields change tables.

model media {
  id                     Int      @id @default(autoincrement())
  user_id                Int?
  day_id                 Int?
  thought_id             Int?
  moment_id              Int?
  greatfullagain_id      Int?
  field_id               Int?
  //                     media_bucket             just in case this is needed.
  media_tag              String           //   'ketopizza.JPG' .... the AWS-S3 key 
  media_type             String           //  'img', 'mp4', 'wav'
  is_thumbnail           Boolean?         // nullable: if null then not thumbnail(false)
  timestamp              DateTime @default(now())
  updatedAtBin           String[]

  user                   users? @relation("userMedia", fields: [user_id], references: [id])    
  day                    days? @relation("dayMedia", fields: [day_id], references: [id])
  thought                thoughts? @relation("thoughtMedia", fields: [thought_id], references: [id])  
  moment                 moments? @relation("momentMedia", fields: [moment_id], references: [id])
  field                  fields? @relation("fieldMedia", fields: [field_id], references: [id])
  greatfullagain         greatfullagain? @relation("greatfullagainMedia", fields: [greatfullagain_id], references: [id])
}

model decidedo {        
  id                  Int      @id @default(autoincrement()) @unique
  fields_id           Int      
  decide              String
  doings              String[] @default([])      
  //                  zoom_in             String?      
  //                  zoom_out            String?     
  timestamp           DateTime @default(now())
  updatedAtBin        String[]

  field               fields[] @relation("decideDoFields")  
}

model listeners {
  // listening to a post means that when that user updates their post in any way, those listening-users get push-alerted to the changes
  // can't see {greatfullagain_&_zoom_out} without listening to the post. considered the same for {fields_&_dream} but probably not

  id                  Int      @id @default(autoincrement())
  day_id              Int? // non optional but enforcing on client to avoid circular dependency. 
  user_id             Int? // fixing circular dependency issue by making these fields optional
  still_listening     Boolean // have to add something because it's an empty prisma.listeners.create() statement if not. 
  timestamp           DateTime @default(now())
  updatedAtBin        String[]

  day                 days? @relation("dayListeners", fields: [day_id], references: [id])
  user                users? @relation("userListeners", fields: [user_id], references: [id])  
  notifications       notifications[] @relation("listenerNotifications")
}

model likes {
  id                  Int      @id @default(autoincrement())
  liked_by_id         Int?
  day_id              Int?
  thought_id          Int?
  field_id            Int?
  feedgame_id         Int?
  message_id          Int?
  habit               String?

  is_like             Boolean?
  is_dislike          Boolean?
  rlly                String? 
  timestamp           DateTime @default(now())
  updatedAtBin        String[]

  liked_by            users? @relation("userLikes", fields: [liked_by_id], references: [id])    
  days                days? @relation("dayLikes", fields: [day_id], references: [id])      
  
  feedgame            feedgames? @relation("feedgameLikes", fields: [feedgame_id], references: [id])
  message             messages? @relation("messageLikes", fields: [message_id], references: [id])  
  field               fields? @relation("fieldLikes", fields: [field_id], references: [id])

  notification        notifications[] @relation("likeNotifications")
}


model notifications {
  id                    Int      @id @default(autoincrement())
  from_user_id          Int?
  for_user_id           Int?
  from_app              Boolean?
  follower_id           Int?
  day_id                Int?
  thought_id            Int?
  moment_id             Int?
  listener_id           Int?
  share_id              Int?
  like_id               Int?
  star_id               Int?
  reaction_id           Int?
  vibe_id               Int?
  payment_id            Int?
  prank_id              Int?
  feedgame_id           Int?  
  message_id            Int?
  report_id             Int?
  user_pass_lock_id     Int?
  ballot_id             Int?

  is_read               Boolean
  is_request            Boolean?
  type                  String?
  timestamp             DateTime @default(now())
  updatedAtBin          String[]

  from                  users?  @relation("userFromNotifications", fields: [from_user_id], references: [id])
  for                   users?  @relation("userForNotifications", fields: [for_user_id], references: [id])
  
  follower              followers? @relation("followersNotifications", fields: [follower_id], references: [id])
  feedgame              feedgames? @relation("feedgameNotifications", fields: [feedgame_id], references: [id])

  day                   days? @relation("dayNotifications", fields: [day_id], references: [id])
  thought               thoughts?  @relation("thoughtNotifications", fields: [thought_id], references: [id])  
  moment                moments?  @relation("momentNotifications", fields: [moment_id], references: [id])
  listener              listeners? @relation("listenerNotifications", fields: [listener_id], references: [id])
  share                 shares? @relation("shareNotifications", fields: [share_id], references: [id])
  like                  likes? @relation("likeNotifications", fields: [like_id], references: [id])
  star                  stars? @relation("starNotifications", fields: [star_id], references: [id])
  reaction              reactions? @relation("reactionNotifications", fields: [reaction_id], references: [id])
  vibe                  vibes? @relation("vibeNotifications", fields: [vibe_id], references: [id])
  payment               payments? @relation("paymentNotifications", fields: [payment_id], references: [id])
  prank                 pranks? @relation("prankNotifications", fields: [prank_id], references: [id])
  report                reportedcontent? @relation("reportNotifications", fields: [report_id], references: [id])
  userPassLock          userpassdaylocks? @relation("userPassLocksNotifications", fields: [user_pass_lock_id], references: [id])
  ballot                ballots? @relation("ballotNotifications", fields: [ballot_id], references: [id])
  message               messages? @relation("messageNotifications", fields: [message_id], references: [id])
}

model locations {   
  id                  Int      @id @default(autoincrement())
  nickname            String?  @unique
  city                String?
  zip_code            Int?
  country             String?
  //                  iso_code   String?   // would love this feature but can imagine app-community (if exists) not agreeing on region lang
  timestamp           DateTime @default(now())
  updatedAtBin        String[]

  users               users[] @relation("locationUsers")
  days                days[] @relation("locationDays")
  thoughts            thoughts[] @relation("locationThoughts")
  zipcodes            zipcodes[] @relation("locationZipcodes")
  payments            payments[] @relation("locationPayments")
  hashtags            hashtags[] @relation("locationHashtags")
  algo_settings       algosettings[] @relation("locationAlgosettings")
}

model zipcodes {
  id                  Int      @id @default(autoincrement())
  location_id         Int
  zipcode             Int 
  timestamp           DateTime @default(now())
  updatedAtBin        String[]

  location            locations @relation("locationZipcodes", fields: [location_id], references: [id])
}
 
model followers {
  id                  Int      @id @default(autoincrement())
  user_id             Int
  follower_id         Int
  timestamp           DateTime @default(now())
  updatedAtBin        String[]

  user                users  @relation("userFollowers", fields: [user_id], references: [id])
  follower            users  @relation("userFollowing", fields: [follower_id], references: [id])  

  notification        notifications[] @relation("followersNotifications")
}

model privacy {         
  id                  Int      @id @default(autoincrement())
  user_id             Int      @unique       
  private_acct        Boolean         // really was thinking {private_profile} because if private_acct user comments it can be seen?
  can_msg             String  
  anon_msg            String
  
  share_data          Boolean?
  prankable           Boolean?      
  opt_in_feedgame     Boolean? 
  opt_in_thoughtblank Boolean?    // that a user can fire blank thoughts onto your post on weekend posted posts only! 
  opt_in_allours      Boolean?    // SEE_WHOLE_POST === true -> user clicks all parts of post & see other recommended users <days> #content
  show_history        Boolean 
  show_friends        String?   // defaults to 'yes' whether a user can turn off if user can see other users' friends. 
  can_mention         String?   // might not be launching.. 1/7 idea. might be bool too..could be too hard to enforce w/ string
  timestamp           DateTime @default(now())  
  updatedAtBin        String[]

  //                  version             String?   // what journall version the user uses

  users               users @relation("userPrivacy", fields: [user_id], references: [id])  
}

model categories {    
  id                  Int      @id @default(autoincrement())
  name                String          // this used to be the PK but decided to have id since relaunching tables.
  rules               String[]
  timestamp           DateTime  @default(now())
  updatedAtBin        String[]
  
  day                 days[] @relation("categoryDays")
  mods                mods[] @relation("categoryMods")
  algo_settings       algosettings[] @relation("categoryAlgosettings")

  // see below. categories is basically /subreddit  /fb-groups
}

// model camps || groups { } 
// model events 

model mods {
  id                Int      @id @default(autoincrement())
  category_id       Int
  user_id           Int  
  timestamp         DateTime @default(now())
  updatedAtBin      String[]

  category          categories @relation("categoryMods", fields: [category_id], references: [id])
  //                user              users @relation("modUsers", fields: [user_id], references: [id]) // users:mods M:M now but limit to 2
}

model mod_users {
  id                Int      @id @default(autoincrement())
  mod_id            Int?
  user_id           Int?
  timestamp         DateTime @default(now())
  updatedAtBin      String[]
}

model blocks {
  id                Int      @id @default(autoincrement())
  user_id           Int
  blocked_id        Int
  feedback          String?
  notes             String?  
  timestamp         DateTime @default(now())
  updatedAtBin      String[]

  user              users  @relation("userBlocks", fields: [user_id], references: [id])
  blocked           users  @relation("blockedUsers", fields: [blocked_id], references: [id])
}

model suggestions {
    id              Int       @id @default(autoincrement())
    suggested_by    Int
    suggestion      String
    notes           String?
    non_anonymous   Boolean
    timestamp       DateTime @default(now())
    updatedAtBin    String[]
    
    user            users @relation("userSuggestions", fields: [suggested_by], references: [id])
    
    thought         thoughts[] @relation("suggestionThoughts")
    stars           stars[] @relation("suggestionStars")
    ballot          ballots[] @relation("suggestionBallot")    
}

model stars {
  id                 Int      @id @default(autoincrement())
  user_id            Int
  day_id             Int?     // initially made table not seeing need for this. way easier to make parent post referenceable
  username           String?
  user_profile_icon  String?
  //                      user_is_verified        Boolean?

  thought_id         Int?
  //                 thought            string  // considered denormalizing {thoughts.thought} into {table.stars} for <StarsShowUsers/>

  message_id         Int?
  suggestion_id      Int?

  stars              Int
  timestamp          DateTime @default(now())
  updatedAtBin       String[]
  

  user               users @relation("userStars", fields: [user_id], references: [id])
  thought            thoughts? @relation("thoughtStars", fields: [thought_id], references: [id])
  suggestion         suggestions? @relation("suggestionStars", fields: [suggestion_id], references: [id])
  notification       notifications[] @relation("starNotifications")  
  message            messages? @relation("messageStars", fields: [message_id], references: [id])
}


model shares {
  id                Int      @id @default(autoincrement())
  day_id            Int?
  thought_id        Int?
  field_id          Int?
  sharer_id         Int?
  timestamp         DateTime @default(now())
  updatedAtBin      String[]
 
  day               days? @relation("dayShares", fields:[day_id], references: [id])
  thought           thoughts? @relation("thoughtShares", fields: [thought_id], references: [id])    // basically retweet lol.
  field             fields? @relation("fieldShares", fields: [field_id], references: [id])
  sharer            users? @relation("userShares", fields: [sharer_id], references: [id])
  
  notifications      notifications[] @relation("shareNotifications") 
}

model reactions {
  id                 Int      @id @default(autoincrement())
  user_id            Int?
  day_id             Int?
  feedgame_id        Int?
  message_id         Int?
  value_id           Int?
  habit_id           Int?
  meme_id            Int?  
  reaction           String  
  timestamp          DateTime @default(now())
  updatedAtBin       String[]

  user               users?  @relation("userReactions", fields: [user_id], references: [id])
  day                days? @relation("dayReactions", fields: [day_id], references: [id])

  feedgame           feedgames? @relation("feedgameReactions", fields: [feedgame_id], references: [id])
  message            messages? @relation("messageReactions", fields: [message_id], references: [id])  

  notification       notifications[] @relation("reactionNotifications")
}

model vibes {        
  id                  Int      @id @default(autoincrement())
  for_user            Int
  from_user           Int
  day_id              Int
  timestamp           DateTime @default(now())
  updatedAtBin        String[]

  notification        notifications[] @relation("vibeNotifications") 
}

model payments {      
  id                  Int      @id @default(autoincrement())
  from_user_id        Int?
  for_user_id         Int?
  is_app_payment      Boolean
  day_id              Int?
  location_id         Int?
  last_4              Int
  ip_addy             String  
  notes               String        
  amount              Int
  currency            String
  timestamp           DateTime @default(now())
  updatedAtBin        String[]

  from_me_pay         users? @relation("fromUserPayments", fields: [from_user_id], references: [id])
  for_me_pay          users? @relation("forUserPayments", fields: [for_user_id], references: [id])
  day                 days?  @relation("dayPayments", fields: [day_id], references: [id])
  location            locations? @relation("locationPayments", fields: [location_id], references: [id])
  notifications       notifications[] @relation("paymentNotifications")
}

model pranks {
  id                  Int      @id @default(autoincrement())
  pranked_by_id       Int?  
  pranked_user_id     Int?
  day_id              Int? 
  prank               String  
  active              Boolean  
  timestamp           DateTime @default(now())
  updatedAtBin        String[]

  prankster           users? @relation("userPranks", fields: [pranked_by_id], references: [id])
  pranked             users? @relation("userPranked", fields: [pranked_user_id], references: [id])

  day                 days? @relation("dayPranks", fields: [day_id], references: [id])
  notifications       notifications[] @relation("prankNotifications")
}

model hashtags {        
  id                  Int      @id @default(autoincrement())
  tag                 String? 
  location_id         Int? 
  no_db_loc           String?  

  timestamp           DateTime @default(now())
  updatedAtBin        String[]

  location            locations? @relation("locationHashtags", fields: [location_id], references: [id])
  algo_settings       algosettings[] @relation("hashtagAlgosettings")
}

model hashtaggedcontent {
  id                Int      @id @default(autoincrement())    
  user_id           Int
  hashtag_id        Int
  day_id            Int?
  thought_id        Int?
  category          String?
  timestamp         DateTime @default(now())
  updatedAtBin      String[]
}

model feedgames {
  id                Int      @id @default(autoincrement())
  gametype          String
  timestamp         DateTime @default(now())
  updatedAtBin      String[]

  thought           thoughts[] @relation("feedgameThoughts")
  like              likes[] @relation("feedgameLikes")              
  reaction          reactions[] @relation("feedgameReactions")       

  notification      notifications[] @relation("feedgameNotifications")  
  ballot            ballots[] @relation("feedgameBallot") 
}

model messages {
  id                Int      @id @default(autoincrement())
  user_id           Int
  from_id           Int
  msg               String
  non_anonymous     Boolean
  timestamp         DateTime @default(now())
  updatedAtBin      String[]

  notification      notifications[] @relation("messageNotifications")
  reaction          reactions[] @relation("messageReactions")
  like              likes[] @relation("messageLikes")
  stars             stars[] @relation("messageStars")

  user              users  @relation("userForMessages", fields: [user_id], references: [id])
  from              users  @relation("userFromMessages", fields: [from_id], references: [id])
}

model reportedcontent {
  id                Int      @id @default(autoincrement())
  reported_user     Int
  reporting_user    Int

  day_id            Int?
  thought_id        Int?
  suggestion_id     Int?
  why               String?
  status            String?
  notes             String?
  timestamp         DateTime @default(now())
  updatedAtBin      String[]

  notification      notifications[] @relation("reportNotifications") 
}

model showsuscontentusers {       
  id                Int      @id @default(autoincrement())
  thought_id        Int?
  day_id            Int?
  scroll_user_id    Int
  timestamp         DateTime @default(now())
  updatedAtBin      String[]
}


model trash {
  id                Int      @id @default(autoincrement())  
  trashed_by_id     Int
  day_id            Int?
  thought_id        Int?
  trashed_count     Int  
  is_in_trash       Boolean                 // this field replaces need for {model.trashedposts} Once it hits a certain number its in the trash 
  timestamp         DateTime @default(now())
  updatedAtBin      String[]
}

// NO!!! {trashedposts} once post hits a certain number it hits the trash. needs algo cuz 10 follower count # won't be 1m followers 
// model trashlist { } 1:M        

model userpassdaylocks {      
  id                  Int      @id @default(autoincrement())
  day_id              Int
  user_id             Int
  timestamp           DateTime @default(now())
  updatedAtBin        String[]

  notifications       notifications[] @relation("userPassLocksNotifications")
}

model mentions {
  id                Int      @id @default(autoincrement())
  menionted_by_id   Int
  mentioned_user_id Int
  day_id            Int?
  thought_id        Int?
  moment_id         Int?
  greatfullagain_id Int?
  field_id          Int?
  timestamp         DateTime @default(now())
  updatedAtBin      String[]

}


// model pins { } // would this be it's own table or just bool field in { thoughts|comments } model. post can be pinned on profile too

model ballots {
    id              Int       @id @default(autoincrement())
    feedgames_id    Int?        
    day_id          Int?    
    started_by_id   Int?
    suggestion_id   Int?
    ourconcern_id   Int?
    ourquestion_id  Int?
    ourcriticism_id Int?
    ourhabit_id     Int?
    ourvalue_id     Int?
    title           String?     
    description     String?
    decision        String?
    notes           String?
    option          String?
    restriction     String?
    options         String[] @default([])
    timestamp       DateTime @default(now())
    updatedAtBin    String[]
    
    feedgames       feedgames? @relation("feedgameBallot", fields: [feedgames_id], references: [id])
    day             days? @relation("dayBallot", fields: [day_id], references: [id])
    suggestion      suggestions? @relation("suggestionBallot", fields: [suggestion_id], references: [id])
    ourconcern      ourconcerns? @relation("ourConcernBallots", fields: [ourconcern_id], references: [id])
    ourquestion     ourquestions? @relation("ourQuestionBallots", fields: [ourquestion_id], references: [id])
    ourcriticism    ourcriticisms? @relation("ourCriticismBallots", fields: [ourcriticism_id], references: [id])
    ourhabit        ourhabits? @relation("ourHabitBallots", fields: [ourhabit_id], references: [id])
    ourvalue        ourvalues? @relation("ourValueBallots", fields: [ourvalue_id], references: [id])

    user            users? @relation("ballotStartedByUser", fields: [started_by_id], references: [id])
    votes           votes[] @relation("ballotVotes")
    notifications   notifications[] @relation("ballotNotifications")
}

model votes {  
  id                Int       @id @default(autoincrement())
  ballot_id         Int?
  user_id           Int?    // ... circular dependency but won't be taking votes without users. M:M so no mention of table. 
  vote              Int
  timestamp         DateTime @default(now())
  updatedAtBin      String[]
  
  ballot            ballots? @relation("ballotVotes", fields: [ballot_id], references: [id])
  // no association for user since it's M:M? 
}

model algosettings {     
  id                  Int      @id @default(autoincrement())
  user_id             Int?      
  hashtag_id          Int?
  location_id         Int?
  layout              String? 
  concern_id          Int?
  question_id         Int?
  criticism_id        Int?
  field_id            Int?
  category_id         Int?

  nickname            String?
  include_words       String[] @default([])
  exclude_words       String[] @default([])
  gender              String? 
  engaged_percent     Int? 
  verified            String?
  trash_percent       Int?
  reactions           String? 
  anonymous_percent   Int? 
  is_anonymous        String?
  after_join_date     String?
  post_percent        Int?       
  feedgame_percent    Int?    
  spam_percent        Int?
  timestamp           DateTime @default(now())
  updatedAtBin        String[]
  feed_axis_x         String?   // the horizontal "o o o o o o" user profile icons. can now be stories, shorts, userprofiles, moments, feedgames

  user                users? @relation("userAlgosettings", fields: [user_id], references: [id])
  hashtag             hashtags? @relation("hashtagAlgosettings", fields: [hashtag_id], references: [id])
  location            locations? @relation("locationAlgosettings", fields: [location_id], references: [id])
  myconcern           myconcerns? @relation("myConcernAlgosettings", fields: [concern_id], references: [id])
  myquestion          myquestions? @relation("myQuestionAlgosettings", fields: [question_id], references: [id])
  mycriticism         mycriticisms? @relation("myCriticismAlgosettings", fields: [criticism_id], references: [id])

  field               fields? @relation("fieldAlgosettings", fields: [field_id], references: [id])
  category            categories? @relation("categoryAlgosettings", fields: [category_id], references: [id])
}
